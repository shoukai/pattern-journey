# 命令模式

意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。

![](http://cdn.apframework.com/81268467356fb79ba960bd6f06bb966a.jpg)

## 相关概念
### 模式意图
意图：**将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化**。
概念：在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）。
说白了，就是将一系列的请求命令封装起来，不直接调用真正执行者的方法，这样比较好扩展。

### 模式示例
装修新房的最后几道工序之一是安装插座和开关，通过开关可以控制一些电器的打开和关闭，例如电灯或者排气扇。在购买开关时，我们并不知道它将来到底用于控制什么电器，也就是说，开关与电灯、排气扇并无直接关系，一个开关在安装之后可能用来控制电灯，也可能用来控制排气扇或者其他电器设备。开关与电器之间通过电线建立连接，如果开关打开，则电线通电，电器工作；反之，开关关闭，电线断电，电器停止工作。相同的开关可以通过不同的电线来控制不同的电器，如图1所示：

![](/command/doc/pic-01.jpg)

在图1中，我们可以将开关理解成一个请求的发送者，用户通过它来发送一个“开灯”请求，而电灯是“开灯”请求的最终接收者和处理者，在图中，开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。

### 模式解析
在命令模式结构图中包含如下几个角色：
* Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。
* ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。
* Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。
* Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。
命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。
 命令模式的**关键在于引入了抽象命令类**，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。
最简模式类图

![](/command/doc/pic-02.jpg)

刚才的例子

![](/command/doc/pic-03.jpg)

组合其他模式

![](/command/doc/pic-04.jpg)

* 优点：扩展性
1. 降低对象之间的耦合度。
2. 新的命令可以很容易地加入到系统中。
3. 可以比较容易地设计一个**组合命令**。
4. 调用同一方法实现不同的功能
* 缺点
使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。

## 相关代码
命令接口（电线）
```
//抽象命令类：抽象的命令，可以根据不同类型的命令写出不同的实现
public interface Command {
    //调用命令
    void execute();
}
```
具体命令（具体电线）
```
//具体命令类
class ConcreteCommand implements Command {

    //持有真正执行命令对象的引用
    private Receiver receiver;

    public ConcreteCommand(Receiver receiver) {
        super();
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        //调用接收者执行命令的方法
        receiver.action();
    }
}
```
调用者（开关）
```
//请求者/调用者：发起执行命令请求的对象
public class Invoker {
    //持有命令对象的引用
    private Command command;

    public Invoker(Command command) {
        super();
        this.command = command;
    }

    //请求者调用命令对象执行命令的那个execute方法
    public void call() {
        command.execute();
    }
}
```
命令执行者（具体电器：灯、风扇）
```
//接收者：真正执行命令的对象
public class Receiver {
    public void action() {
        System.out.println("命令执行了.......");
    }
}
```
主函数调用（现实生活中分为两部分：电器工程师负责前两行，我们负责最后一行）
```
public static void main(String[] args) {
    //通过请求者（invoker）调用命令对象（command），命令对象中调用了命令具体执行者（Receiver）
    Command command = new ConcreteCommand(new Receiver());
    Invoker invoker = new Invoker(command);
    invoker.call();
}
```

## 参考
* [java设计模式之命令模式 - 持＆恒 - 博客园](https://www.cnblogs.com/lfxiao/p/6825644.html)
* [Java23种设计模式学习笔记](http://www.cnblogs.com/meet/p/5116504.html)
* [java-design-patterns](https://github.com/iluwatar/java-design-patterns)




#技术/设计模式