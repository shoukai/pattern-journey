# 抽象工厂模式

工厂模式实现了创建者和调用者的分离

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

**意图**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决**：主要解决接口选择的问题。

**何时使用**：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决**：在一个产品族里面，定义多个产品。

**关键代码**：在一个工厂里聚合多个同类产品。

### 工厂模式分类：

1. 简单工厂模式

2. 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类

​3. 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

### 抽象工厂模式

抽象工厂模式用来生产不同产品族的全部产品，对于只增加产品某一部分则不适用。抽象工厂模式是工厂模式的一种升级版本。

在有多个业务品种，业务分类时，抽象工厂能产品不同类别的一个全部产品。例如：生产汽车，抽象工厂模式可以生产高端汽车全部配件来组成一个高端汽车，

低端汽车全部配件来组成要给低端的汽车，但是不能产生一个高端的发动机和一个低端的座椅来组成一个中等的汽车。这样会混乱。

### 工厂模式要点

* 简单工厂模式（静态工厂模式）

虽然某种程度不符合面向对象规则（不符合开闭原则，每次新增内容都需要在原有代码上修改），但是实际使用最多。

个人理解：通过调用factory传入type创建满足要求的对象

* 工厂方法模式

不修改已有类的前提下，通过增加新类来实现扩展。

个人理解：编写不同类型的factory满足创建单一对象要求

* 抽象工厂模式

不可以增加产品中某一个配件，可以增加一个具体的产品族。

个人理解：编写不同类型的factory满足创建一个产品族（高档、中档、种族）的对象要求

### 实现

![](http://skblog.duiduiche.com/fd1810c243b10efdd8b2f2df37eeb9c5.jpg)

### 参考

* [Java23种设计模式学习笔记](http://www.cnblogs.com/meet/p/5116504.html)
* [java-design-patterns](https://github.com/iluwatar/java-design-patterns)
* [抽象工厂模式-菜鸟教程](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)


