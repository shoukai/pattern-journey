# 责任链模式介绍

意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

何时使用：在处理消息的时候以过滤很多道。

如何解决：拦截的类都实现统一接口。

### 责任链模式：

将能够处理同一类请求的对象连成一条链，使这些对象都有机会处理请求，所提交的请求沿着链传递。从而避免请求的

发送者和接受者之间的耦合关系。链上的对象逐个判断是否有能力处理该请求，如果能则就处理，如果不能，则传给链上的下一个对象。

直到有一个对象处理它为止。

### 场景：

1. 打牌时，轮流出牌

2. 接力赛跑

3. 请假审批

4. 公文审批

### 实现方式：

1. 链表方式：比如刚才的请假审批

2. 非链表方式：通过集合，数组生成责任链更加实用，将链表上的各个对象都添加到集合中，然后通过反射给构建出来。

然后在容器里一个个的处理。（也就是说把测试代码中除了请假的其他代码都给用一个类来处理）

### 开发中常见场景：

1. Java的异常机制就是一个责任链模式，一个try可以对应多个cathc。如果某一个catch不匹配，则跳到下一个catch中

2. JavaScript语言中的事件的冒泡和捕获机制

3. Servlet开发中，过滤器的链式处理

4. Struts2中，拦截器的调用也是典型的责任链模式

### 责任链的好处：

​1. 接受者和发送者都没有对方的明确信息，且链中的对象也并不知道链的结构，结果是责任链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需要保持它所有的候选继承者，大大的降低了耦合度。请求者不用管具体哪个对象会处理，反正该请求肯定会被处理就行了。

2. 可以随时增加或者修改处理一个请求的结构，增加了给对象指派职责的灵活性

